---
counter: True
---

# Chapter 4 | Leftist Heap & Skew Heap

## Leftist Heap

!!! quote "link"
    OI Wiki: https://oi-wiki.org/ds/leftist-tree/

    Wikipedia: https://en.wikipedia.org/wiki/Leftist_tree

---

### æ¦‚è¿°
!!! note "Preview of Binary Heap"
    ç®€å•è¿‡ä¸€ä¸‹äºŒå‰å †æ¯”è¾ƒé‡è¦çš„å‡ ä¸ªæ“ä½œï¼ˆä»¥æœ€å°å †ä¸ºä¾‹ï¼‰

    - **Insert**:æ’å…¥åˆ°äºŒå‰å †çš„æœ«å°¾ï¼Œå†Percolate Up:$O(log(n))$
    - **FindMin**:ç›´æ¥å¼¹å‡ºæœ€é¡¶ä¸Šçš„å…ƒç´ :$O(1)$
    - **DeleteMin**:åˆ é™¤æœ€é¡¶ä¸Šçš„å…ƒç´ ï¼Œä»¥æœ«å°¾å…ƒç´ æ›¿ä»£ä¹‹ï¼Œå†Percolate Down:$O(log(n))$
    - **BuildHeap**:å¯ä»¥æ‰§è¡Œè¿ç»­æ’å…¥:$nO(log(n))$;æ›´å¥½çš„æ–¹å¼æ˜¯å…¨éƒ¨æ’åˆ—å¥½ï¼Œä»å€’æ•°ç¬¬äºŒå±‚å¼€å§‹Percolate Up:$O(n)$ -- from course DS
    - ~~**Merge(Meld)**~~:ç±»ä¼¼BuildHeapï¼Œå¯ä»¥å°†ä¸€ä¸ªäºŒå‰å †ä¸­çš„å…ƒç´ ä¾æ¬¡æ’å…¥å¦ä¸€ä¸ªäºŒå‰å †ï¼›ä½†æ›´å¥½çš„æ–¹å¼æ˜¯å…¨éƒ¨æ‰“ä¹±å†BuildHeap:$O(n)$

æˆ‘ä»¬ä¸å¤ªæ»¡æ„Binary Heapçš„Mergeï¼Œå› ä¸ºå…¨éƒ¨æ‰“ä¹±å†BuildHeapçš„æ“ä½œæ¶ˆè§£äº†ä¸¤ä¸ªHeapçš„ç‰¹å¾ï¼Œè™½ç„¶è¯´$O(n)$å·²ç»ä¸é”™äº†ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æƒ³æ‰¾åˆ°æ›´å¥½çš„ç»“æ„æ¥è¿›è¡Œå¿«é€Ÿçš„å †åˆå¹¶æ“ä½œï¼Œäºæ˜¯å·¦åå †(Leftist Heap)åº”è¿è€Œç”Ÿ,å®ƒçš„å †åˆå¹¶æ“ä½œçš„å¤æ‚åº¦åªè¦$O(log(n))$

!!! note "@cy's ppt"
    **Leftist Heap:**
    Order Property â€“ the same
    Structure Property â€“ binary tree, but unbalanced

å·¦åå †(Leftlist Heap)ä¹Ÿæ˜¯ä¸€é¢—äºŒå‰æ ‘ï¼Œä¸ä»…å…·æœ‰å †çš„æ€§è´¨ï¼Œå¹¶ä¸”æ˜¯ **ã€Œå·¦åã€** çš„ï¼Œä½†æ˜¯ç”±äºå®ƒå¹¶ä¸å†æ˜¯ä¸€é¢—å®Œå…¨äºŒå‰æ ‘ï¼Œæ‰€ä»¥ä¸èƒ½åƒç»´æŠ¤å¤§å°å †ä¸€æ ·ç”¨æ•°ç»„æ¥ç»´æŠ¤å®ƒ

!!! question "Why arrays?"
    è¿™é‡Œæä¸€å˜´ä¸ºä»€ä¹ˆå †ä¼šç”¨æ•°ç»„å­˜å‚¨ï¼Œä½¿ç”¨æ•°ç»„æ¥å­˜å‚¨å †çš„èŠ‚ç‚¹ä¿¡æ¯ï¼Œæœ‰ä¸€ç§å¤©ç„¶çš„ä¼˜åŠ¿é‚£å°±æ˜¯èŠ‚çœå†…å­˜ç©ºé—´ã€‚å› ä¸ºæ•°ç»„å ç”¨çš„æ˜¯è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œç›¸å¯¹äºæ•£åˆ—å­˜å‚¨çš„ç»“æ„æ¥è¯´ï¼Œæ•°ç»„å¯ä»¥èŠ‚çœè¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œä¸ä¼šå°†å†…å­˜æ‰“ä¹±ã€‚

---

### å®šä¹‰
ä¸€ä¸ªå·¦åå †çš„ç»“ç‚¹ç»´æŠ¤äº†å·¦å³å­å †çš„åœ°å€ã€è‡ªèº«çš„é”®å€¼ã€å’Œä¸€ä¸ª**è·ç¦»(dist)**/**Npl(null path length)**

```cpp
struct LeftistHeapNode {
    ElementType val;
    int dist;
    LeftistHeapNode * ls, * rs;
};
```

!!! definition "@cy's ppt"
    [Definition] **The null path length**,**Npl**(x),of any node X is the length of the shortest path from X to a node without two children. Define Npl(NULL) = -1.

    [Definition] **The leftist heap property** is that for every node X in the heap, the null path length of the left child is at least as large as that of the right child.

    ç®€å•æ¥è¯´ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½é¢å¤–å­˜å‚¨äº†å®ƒåˆ°å°äº2ä¸ªå­©å­çš„èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦» dist/Nplï¼Œå¹¶ä¸”å¯¹ä»»æ„èŠ‚ç‚¹è€Œè¨€ï¼Œå®ƒçš„å·¦å­©å­çš„ dist >= å³å­©å­çš„dist
    éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œdist ä¸æ˜¯æ·±åº¦ï¼Œå·¦åæ ‘çš„æ·±åº¦æ²¡æœ‰ä¿è¯ï¼Œä¸€æ¡å‘å·¦çš„é“¾ä¹Ÿç¬¦åˆå·¦åæ ‘çš„å®šä¹‰ã€‚

---

### æ€§è´¨
!!! property "properties"
    1. ç»“ç‚¹çš„ $dist$ ç­‰äº $dist_\text{right child} + 1$ï¼ˆå‡è®¾ $dist_\text{NULL} = -1$ï¼‰ï¼›æˆ–è€…å¯ä»¥è¯´ç»“ç‚¹çš„ $dist$ å°±æ˜¯æœ€å³è·¯å¾„çš„èŠ‚ç‚¹æ•°
    2. å¦‚æœ $dist_i = N$ï¼Œåˆ™ä»¥ $i$ ä¸ºæ ¹çš„å­æ ‘**è‡³å°‘**æ˜¯ä¸€ä¸ª $N+1$ å±‚çš„å®Œç¾äºŒå‰æ ‘ï¼Œè‡³å°‘æœ‰ $2^{N+1}-1$ ä¸ªç»“ç‚¹
    3. æœ€å³è·¯å¾„æœ‰ r ä¸ªèŠ‚ç‚¹çš„å·¦æ–œå †è‡³å°‘æœ‰$2^r - 1$ä¸ªèŠ‚ç‚¹ / æœ‰ N ä¸ªèŠ‚ç‚¹çš„å·¦æ–œå †çš„æœ€å³è·¯å¾„æœ€å¤šæœ‰ $\log_2(N+1)$ ä¸ªèŠ‚ç‚¹ 
    
    å…¶ä¸­å‘½é¢˜ 2 å’Œå‘½é¢˜ 3 äº‹å®ä¸Šæ˜¯ç­‰ä»·çš„

    ??? proof "è¯æ˜"
        é¦–å…ˆæˆ‘ä»¬æ˜ç¡®ï¼Œå¦‚æœä¸€æ£µæ ‘çš„æœ€å³è·¯å¾„æœ‰ r ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™æ£µæ ‘çš„ dist å°±ç­‰äº rï¼ˆæ ¹æ®æ€§è´¨1ï¼‰/ ç”šè‡³å…¶å®æˆ‘ä»¬å°±å¯ä»¥å°† dist å®šä¹‰ä¸ºæœ€å³è·¯å¾„çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
        æˆ‘ä»¬ç”¨æ•°å­¦å½’çº³æ³•åŠ ä»¥è¯æ˜ï¼š

        1. è‹¥ r = 1ï¼Œæœ€å³è·¯å¾„æœ‰1ä¸ªèŠ‚ç‚¹ï¼Œå‘½é¢˜æˆç«‹ï¼›
   
        2. å‡è®¾å‘½é¢˜å¯¹äº2,3,4,5,....rå‡æˆç«‹ï¼Œè€ƒè™‘å·¦æ–œå †æœ€å³è·¯å¾„å…·æœ‰ r+1 ä¸ªèŠ‚ç‚¹çš„æƒ…å†µï¼šæ ¹èŠ‚ç‚¹çš„å³å­©å­çš„æœ€å³è·¯å¾„æœ‰ r ä¸ªèŠ‚ç‚¹ï¼Œå³å­©å­æ ‘è‡³å°‘æœ‰$2^r - 1$ä¸ªèŠ‚ç‚¹ï¼›å·¦å­©å­çš„æœ€å³è·¯å¾„ä¹Ÿè‡³å°‘è¦æœ‰ r ä¸ªèŠ‚ç‚¹æ‰èƒ½æ»¡è¶³æ ¹èŠ‚ç‚¹çš„å·¦å€¾æ€§è´¨ï¼Œå› æ­¤å·¦å­©å­æ ‘ä¹Ÿè‡³å°‘è¦æœ‰$2^r - 1$ä¸ªèŠ‚ç‚¹ï¼›å› æ­¤æ ¹èŠ‚ç‚¹çš„è¿™æ£µæ ‘è‡³å°‘æœ‰$2*(2^r - 1) + 1 = 2^{r+1} - 1$ä¸ªèŠ‚ç‚¹
   
        æ‰€ä»¥è¿™ä¸ªå®šç†æˆç«‹ï¼Œå…¶å®ä¹Ÿå°±å¯ä»¥è¯æ˜åˆå¹¶çš„æ“ä½œæ˜¯ $log(n)$ çº§åˆ«çš„
    ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/22.svg){width=49%}
    ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/23.svg){width=43%}
    > æ³¨æ„ï¼Œåœ¨ç¤ºæ„å›¾ä¸­æˆ‘ä»¬çœç•¥äº†ç»“ç‚¹è‡ªèº«é”®å€¼çš„æ ‡è®°ï¼Œä½†æ—¢ç„¶ä½œä¸ºä¸€ä¸ªå †ï¼Œå®ƒå°±éœ€è¦æ»¡è¶³å †çš„æ€§è´¨ï¼Œå³ç»“ç‚¹çš„é”®å€¼ä¸å¤§äºï¼ˆä¸å°äºï¼‰å…¶å­©å­ç»“ç‚¹çš„é”®å€¼ã€‚åœ¨å®é™…ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œé”®å€¼å¾ˆå¯èƒ½ä¸å†æ˜¯å•çº¯çš„æ•°ï¼Œå¤§å°å…³ç³»å¯èƒ½è½¬åŒ–ä¸ºååºå…³ç³»ã€‚

---

### æ“ä½œ
å·¦åå †çš„æ ¸å¿ƒæ“ä½œå°±æ˜¯åˆå¹¶ã€‚è€Œå…¶å®ƒæ“ä½œéƒ½å¯ä»¥çœ‹ä½œæ˜¯åˆå¹¶çš„ç‰¹æ®Šæƒ…å†µã€‚å› æ­¤æˆ‘ä»¬é¦–å…ˆè®¨è®ºä»»æ„ä¸¤ä¸ªå·¦åå †çš„åˆå¹¶ã€‚

---

#### åˆå¹¶
ä½œä¸ºå·¦åå †çš„æ ¸å¿ƒæ“ä½œï¼Œåˆå¹¶æ“ä½œè‡ªç„¶å°±æ˜¯è¦åœ¨æ»¡è¶³æ€§è´¨çš„æ¡ä»¶ä¸‹ï¼Œåˆå¹¶ä¸¤ä¸ªå·¦åå †ã€‚å¤§è‡´æ€è·¯å°±æ˜¯å…ˆç»´æŠ¤å †çš„æ€§è´¨ï¼Œåœ¨å›æº¯æ—¶ç»´æŠ¤å·¦åæ€§è´¨ï¼Œæ‰€ä»¥å®é™…ä¸Šå®ƒæ˜¯ä¸€ä¸ªå…ˆè‡ªä¸Šè€Œä¸‹å†è‡ªä¸‹è€Œä¸Šçš„è¿‡ç¨‹ã€‚

æŒ‰ç…§å®ç°æ–¹æ³•ï¼Œå·¦åå †çš„åˆå¹¶å¯ä»¥åˆ†ä¸ºé€’å½’å¼å’Œè¿­ä»£å¼ä¸¤ç§ã€‚å…¶ä¸­å‰è€…å¯èƒ½æ›´ä¸ºç›´è§‰ï¼Œè€Œåè€…å¯è§†åŒ–ååˆ™æ›´ä¸ºç›´è§‚ã€‚

---

##### é€’å½’å¼
é€’å½’å¼å…ˆæ¯”è¾ƒå½“å‰ä¸¤ä¸ªå¾…åˆå¹¶å­æ ‘çš„æ ¹ç»“ç‚¹çš„é”®å€¼ï¼Œé€‰æ‹©è¾ƒå°ï¼ˆè¾ƒå¤§ï¼‰çš„é‚£ä¸ªä½œä¸ºæ ¹ç»“ç‚¹ï¼Œå…¶å·¦å­æ ‘ä¾ç„¶ä¸ºå·¦å­æ ‘ï¼Œå³å­æ ‘æ›´æ–°ä¸ºã€Œå³å­æ ‘å’Œå¦ä¸€ä¸ªå¾…åˆå¹¶å­æ ‘çš„åˆå¹¶ç»“æœã€ã€‚

å½“ç„¶ï¼Œåœ¨é€’å½’åœ°æ›´æ–°å®Œåï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥å·¦å­æ ‘å’Œå³å­æ ‘æ˜¯å¦æ»¡è¶³ $dist_\text{left child} \geq dist_\text{right child}$çš„æ€§è´¨ï¼Œå¦‚æœä¸æ»¡è¶³ï¼Œæˆ‘ä»¬åˆ™éœ€è¦äº¤æ¢å·¦å³å­æ ‘æ¥ç»´æŒæ€§è´¨ã€‚

```cpp
LeftistHeapNode * merge(LeftistHeapNode * x, LeftistHeapNode * y) {
    // Recursive exit. If any is NULL, return the other as the new root of subtree.
    if (x == NULL) return y;
    if (y == NULL) return x;
    
    // If `x`'s val is smaller than `y`'s, swap them, which means we always operates on `x`.
    if (x->val > y->val) {
        swap(x, y);
    }
    
    // Merge `x`'s right subtree and `y`, and set `x`'s right subtree to the result.
    x->rs = merge(x->rs, y);
    
    // If `x`'s left subtree's dist is smaller than `x`'s right subtree's dist, swap them.
    if (x->ls->dist == NULL || x->ls->dist < x->rs->dist) {
        swap(x->ls, x->rs);
    }

    // Update x's dist.
    x->dist = x->rs->dist + 1;

    // Return x as the new root of subtree.
    return x;
}
```
!!! eg "ğŸŒ°"
    ç°åœ¨æˆ‘ä»¬æ¨¡æ‹Ÿä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼Œç°åœ¨æˆ‘ä»¬æœ‰ä¸‹é¢ä¸¤ä¸ªå·¦åå †ï¼Œå°è¯•åˆå¹¶å®ƒä»¬ã€‚

    === "Frame 0"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/24.svg)
    === "Frame 1"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/25.svg)

        æˆ‘ä»¬å‘ç°ï¼Œç»è¿‡æ¯”è¾ƒï¼Œ<font color=#2ECC71>**â¶**</font> æ›´å°ï¼Œæ‰€ä»¥æˆ‘ä»¬å°† <font color=#2ECC71>**â¶**</font> ä½œä¸ºåˆå¹¶åçš„æ ¹ç»“ç‚¹ï¼Œå·¦å­æ ‘ä¸å˜ï¼Œå³å­æ ‘æ›´æ–°ä¸ºã€Œç»¿æ ‘å³å­æ ‘å’Œè“æ ‘çš„åˆå¹¶ç»“æœã€ã€‚
    === "Frame 2"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/26.svg)

        ç»è¿‡æ¯”è¾ƒï¼Œ<font color=#2E86C1>**â·**</font> æ›´å°ï¼Œæ‰€ä»¥æˆ‘ä»¬å°† <font color=#2E86C1>**â·**</font> ä½œä¸ºåˆå¹¶åçš„æ ¹ç»“ç‚¹ï¼Œå·¦å­æ ‘ä¸å˜ï¼Œå³å­æ ‘æ›´æ–°ä¸ºã€Œè“æ ‘å³å­æ ‘å’Œç»¿æ ‘çš„åˆå¹¶ç»“æœã€ã€‚
    === "Frame 3"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/25.svg)

        æœ€åè¿˜å‰©ä¸‹ä¸¤ä¸ªç»“ç‚¹å•¦ï¼å®é™…ä¸Šè¿™é‡Œç›´æ¥æ¨¡æ‹Ÿäº†ä¸¤ä¸ªæ­¥éª¤ï¼Œé¦–å…ˆæ˜¯æ¯”è¾ƒ <font color=#2ECC71>**âº**</font> å’Œ <font color=#2E86C1>**â»**</font>ï¼Œå¹¶é€‰æ‹©äº† <font color=#2ECC71>**âº**</font> ä½œä¸ºæ–°æ ¹ï¼›æ¥ä¸‹æ¥åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­å‘ç°éœ€è¦åˆå¹¶ `NULL` å’Œ <font color=#2E86C1>**â»**</font>ï¼Œæ‰€ä»¥ç›´æ¥è¿”å›äº† <font color=#2E86C1>**â»**</font>ã€‚

        ç„¶è€Œè¿˜æ²¡æœ‰ç»“æŸï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¤„ç†å·¦å³å­æ ‘ dist å¤§å°å…³ç³»é—®é¢˜ã€‚
    === "Frame 4"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/28.svg)

        æˆ‘ä»¬å‘ç° <font color=#2ECC71>**âº**</font> çš„å·¦å­©å­ä¸º `NULL`ï¼Œæˆ‘ä»¬è®° $dist_\text{NULL} = -1$ï¼Œå³å­©å­ <font color=#2E86C1>**â»**</font> æœ‰ $dist_\text{right child}=0$ï¼Œæ‰€ä»¥éœ€è¦äº¤æ¢ä¸¤ä¸ªå­©å­ã€‚
    === "Frame 5"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/29.svg)

        è¿™é‡Œä¹Ÿè·³è¿‡äº†ä¸¤ä¸ªæ­¥éª¤ï¼š

        å¾€å›èµ°ï¼Œå‘ç° <font color=#2ECC71>**âº**</font> çš„ dist å°äº <font color=#2E86C1>**â¹**</font> çš„ distï¼Œæ»¡è¶³æ€§è´¨ï¼Œä¸éœ€è¦æ”¹å˜ã€‚
        
        ç»§ç»­å¾€å›èµ°ï¼Œå‘ç° <font color=#2ECC71>**â·**</font> å’Œ <font color=#2E86C1>**â¸**</font> çš„ dist ç›¸åŒï¼Œæ»¡è¶³æ€§è´¨ï¼Œä¹Ÿä¸éœ€è¦æ”¹å˜ã€‚
        
        ä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºæ¥ï¼Œå¹¶ä¸æ˜¯çœ‹ä¸Šå»æ›´å¤§çš„å­æ ‘ä¸€å®šåœ¨å·¦ä¾§ã€‚
---

##### è¿­ä»£å¼
è¿­ä»£å¼æ˜¯æ ¹æ®å®ƒçš„å®ç°æ–¹æ³•æ¥å‘½åçš„ï¼Œä½†æ˜¯æˆ‘è®¤ä¸ºä»å¯è§†åŒ–çš„è§’åº¦æ¥ç†è§£è¿­ä»£å¼å¯èƒ½æ›´æœ‰æ„æ€ã€‚äº‹å®ä¸Šåœ¨å¾ˆå¤šé¢˜ç›®ä¸­æˆ‘è§‰å¾—è¿™ä¸ªæ–¹æ³•åšé¢˜æ›´åŠ æ–¹ä¾¿ã€‚

è¿­ä»£å¼ç»´æŠ¤ä¸¤ä¸ªé¢å¤–çš„æŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘ä¸¤æ£µæ ‘è¿˜æ²¡è¢«åˆå¹¶çš„å­æ ‘çš„æ ¹ï¼Œå¹¶ä¸æ–­é€‰æ‹©è¾ƒå°çš„é‚£ä¸ªåˆå¹¶è¿›å»ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆéƒ½ä¸ºç©ºã€‚å¯ä»¥å‘ç°ï¼Œè¿™ä¸ªè¿‡ç¨‹å’Œå½’å¹¶æ’åºçš„ååŠéƒ¨åˆ†éå¸¸ç›¸ä¼¼ï¼Œå®é™…ä¸Šå½“æˆ‘ä»¬ä»å¯è§†åŒ–çš„è§’åº¦å»çœ‹è¿™ä»¶äº‹ä»¥åï¼Œä¼šå‘ç°è¿™é‡Œåšçš„**å°±æ˜¯ä¸€ä¸ªå½’å¹¶**ã€‚

```cpp
LeftistHeapNode * merge(LeftistHeapNode * x, LeftistHeapNode * y) {
    // `tx` & `ty` are the pointers to the roots of the subtrees that haven't been merged.
    LeftistHeapNode * tx = x, * ty = y;
    // `res` is the root of the merged final tree, while `cur` is the latest node that has been merged.
    LeftistHeapNode * res = NULL, * cur = NULL;

    // Begin merging.
    whie (tx != NULL && ty != NULL) {
        // If `tx`'s val is smaller than `ty`'s, swap them, which means we always operates on `tx`.
        if (tx->val > ty->val) {
            swap(tx, ty);
        }
        
        // Specially mark the root on the first merge.
        if (res == NULL) {
            res = tx;
            cur = tx;
        } else {
            cur->rs = tx;
            cur = cur->rs;
        }

        // Go on.
        tx = tx->rs;
    }

    // Merge the rest of the tree.
    while (ty != NULL) {
        // Specially mark the root on the first merge. (rarely happens but not impossible)
        if (res == NULL) {
            res = ty;
            cur = ty;
        } else {
            cur->rs = ty;
            cur = cur->rs;
        }

        // Go on.
        ty = ty->rs;
    }

    // Adjust the left and right subtrees of all the nodes according to the properties of `dist`. 
    // It does the same work as the adjust part in the recursive version. I ignore it here.
    res = adjust(res);

    return res;
}
```

ä¾æ—§æ˜¯ä»¥ä¸Šé¢è¿›è¡Œæ¨¡æ‹Ÿçš„é‚£ä¸ªåˆå¹¶ä¸º ğŸŒ° è¿›è¡Œæ¨¡æ‹Ÿã€‚

!!! eg "ğŸŒ°"
    é¦–å…ˆï¼Œæˆ‘ä»¬å¯¹å›¾ç‰‡çš„æ’ç‰ˆç¨å¾®åšä¸€äº›æ”¹å˜ï¼Œæˆ‘ä»¬ä¸å†æŒ‰ç…§ä¹‹å‰ç”»å †çš„æ–¹å¼å»ç”»ï¼Œè€Œæ˜¯â€œå·¦åâ€åœ°å»ç”»ï¼š

    ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/30.svg)

    === "Frame 0"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/31.svg)

        å¯ä»¥å‘ç°ï¼Œåœ¨è°ƒæ•´ä¹‹å‰,ç»¿è‰²å’Œè“è‰²çš„ç®­å¤´åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªå¾…åˆå¹¶å­æ ‘å°šæœªåˆå¹¶çš„å­æ ‘çš„æ ¹ï¼Œç´«è‰²ç®­å¤´è¡¨ç¤ºæœ€è¿‘çš„åˆå¹¶å‘ç”Ÿçš„ä½ç½®ã€‚
    === "Frame 1"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/32.svg)

        æ¯”è¾ƒ <font color=#2ECC71>**â¶**</font> å’Œ <font color=#2E86C1>**â·**</font>ï¼Œå‘ç° <font color=#2ECC71>**â¶**</font> æ›´å°ï¼Œæ‰€ä»¥æˆ‘ä»¬å°† <font color=#2ECC71>**â¶**</font> ä½œä¸ºåˆå¹¶åçš„æ ¹ç»“ç‚¹ï¼Œå·¦å­æ ‘éšä¹‹åˆå¹¶è¿›å»ï¼ŒåŒæ—¶æ›´æ–°ç»¿è‰²ç®­å¤´æŒ‡å‘å°šæœªåˆå¹¶è¿›å»çš„ <font color=#2ECC71>**âº**</font>ã€‚
    === "Frame 2"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/33.svg)

        å’Œä¸Šä¸€æ­¥ç±»ä¼¼çš„ï¼Œæ¯”è¾ƒ <font color=#2ECC71>**âº**</font> å’Œ <font color=#2E86C1>**â·**</font>ï¼Œå‘ç° <font color=#2E86C1>**â·**</font> æ›´å°ï¼Œæ‰€ä»¥æˆ‘ä»¬å°† <font color=#2E86C1>**â·**</font> ä½œä¸ºåˆå¹¶åçš„æ ¹ç»“ç‚¹ï¼Œå·¦å­æ ‘éšä¹‹åˆå¹¶è¿›å»ï¼ŒåŒæ—¶æ›´æ–°è“è‰²ç®­å¤´æŒ‡å‘å°šæœªåˆå¹¶è¿›å»çš„ <font color=#2E86C1>**â»**</font>ã€‚
    === "Frame 3"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/34.svg)

        ä¾ç„¶ç±»ä¼¼åœ°ï¼Œæ¯”è¾ƒ <font color=#2ECC71>**âº**</font> å’Œ <font color=#2E86C1>**â»**</font>ï¼Œå‘ç° <font color=#2ECC71>**âº**</font> æ›´å°ï¼Œæ‰€ä»¥æˆ‘ä»¬å°† <font color=#2ECC71>**âº**</font> ä½œä¸ºåˆå¹¶åçš„æ ¹ç»“ç‚¹ï¼Œå·¦å­æ ‘éšä¹‹åˆå¹¶è¿›å»ï¼ŒåŒæ—¶æ›´æ–°ç»¿è‰²ç®­å¤´æŒ‡å‘ `NULL`ã€‚
    === "Frame 4"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/35.svg)

        è¿™æ—¶å€™æˆ‘ä»¬å‘ç°å·²ç»æœ‰ä¸€ä¸ªæŒ‡é’ˆç©ºäº†ï¼Œä¹Ÿå°±æ˜¯ç»¿è‰²æŒ‡é’ˆå·²ç»æŒ‡å‘äº† `NULL`ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬åªéœ€è¦æŒ‰é¡ºåºæŠŠè“è‰²æŒ‡é’ˆæŒ‡å‘çš„å†…å®¹éƒ½æ¨è¿›å»å³å¯ã€‚
    === "Frame 5"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/36.svg)

        æ¥ä¸‹æ¥æˆ‘ä»¬è¿˜éœ€è¦ç»´æŠ¤ dist ä¿¡æ¯å¹¶æ ¹æ®æ€§è´¨äº¤æ¢å·¦å³å­æ ‘ã€‚è¿™ä¸€éƒ¨åˆ†å’Œä¹‹å‰ä¸€æ ·ï¼Œå°±ä¸å†èµ˜è¿°äº†ã€‚

!!! eg "ğŸŒ°/ğŸ”¥"

    å½“ç„¶ï¼Œè¿™ä¹ˆæ¥çœ‹å¯èƒ½è¿˜æ˜¯å¾ˆä¹±ï¼Œè”æƒ³æˆ‘ä»¬ä¹‹å‰å‘ç°å®ƒå’Œå½’å¹¶æ’åºå¾ˆåƒï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨ä¸€ä¸ªæ›´åŠ ç›´è§‚çš„æ–¹å¼æ¥çœ‹è¿™ä¸ªè¿‡ç¨‹ï¼š

    === "Frame 0"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/30.svg)

        åŒæ ·ä»è¿™å¼ å›¾å¼€å§‹ï¼Œç”±äºæˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼Œå®ƒç±»ä¼¼äºä¸€ä¸ªé€’å½’æ’åºçš„ååŠéƒ¨åˆ†ï¼Œå…·ä½“æ¥è¯´æ˜¯æŒ‡åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°åˆ—çš„è¿‡ç¨‹ã€‚

        ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸¤ä¸ªå·¦åå †æ”¹å†™æˆä¸¤ä¸ªæœ‰åºæ•°åˆ—ï¼
    === "Frame 1"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/37.svg)

        ç”±äºæˆ‘ä»¬åœ¨åˆå¹¶è¿‡ç¨‹ä¸­æ€»æ˜¯æ‰¾å³å­©å­ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±æ²¿ç€æœ€å³æ²¿è·¯å¾„æŠŠæ²¡ä¸ªå·¦åå †æ‹†æˆè¿™ç§â€œæ‚¬åŠâ€çš„å¸¦çŠ¶å½¢å¼ï¼Œæ¯ä¸€â€œæ¡â€çš„å€¼å–å†³äºæ ¹çš„é”®å€¼ï¼Œä¹Ÿå°±æ˜¯è¿™ä¸€â€œæ¡â€çš„æœ€é¡¶éƒ¨ã€‚

        åœ¨è¿™å¼ å›¾ä¸­ï¼Œæˆ‘ä»¬å¾—åˆ°çš„ä¸¤ä¸ª**æœ‰åº**æ•°ç»„åˆ†åˆ«æ˜¯ <font color=#2ECC71>[1, 5]</font> å’Œ <font color=#2E86C1>[2, 6]</font>ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†å®ƒä»¬è¿›è¡Œæ’åºã€‚
    === "Frame 2"
        ![](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/img/38.svg) 

        ç»è¿‡æ’åºï¼Œå°±ä¼šå‘ç°å®ƒä»¬åˆšå¥½ç¬¦åˆæˆ‘ä»¬åœ¨ä¸Šé¢æ­¥éª¤å¾—åˆ°çš„ç»“æœï¼ˆå¯ä»¥å¯¹æ¯”ç€ä¸Šé¢çš„ Frame 4 çœ‹ï¼‰ã€‚å®é™…ä¸Šï¼Œåªè¦ä½ å›é¡¾ä¸€ä¸‹å½’å¹¶æ’åºçš„è¿‡ç¨‹ï¼Œå†å¯¹æ¯”ç€çœ‹ä¸Šé¢çš„è¿‡ç¨‹ï¼Œå°±ä¼šå‘ç°ä¸€æ¨¡ä¸€æ ·ã€‚

åœ¨åšå·¦æ–œå †åˆå¹¶çš„é¢˜ç›®æ—¶ï¼Œä¸ªäººæ¯”è¾ƒå–œæ¬¢è¿­ä»£å¼çš„åšæ³•ï¼Œåªéœ€è¦æ²¿ç€æœ€å³è·¯å¾„æŠŠæ¯ä¸ªå·¦å­æ ‘å†™å‡ºæ¥å†æ’åºï¼Œæœ€åæ²¿ç€æœ€å³è·¯å¾„è¿å›æ¥å³å¯ï¼ˆå½“ç„¶æœ€åè¿˜è¦æ²¿ç€æœ€å³è·¯å¾„å¯¹ dist è¿›è¡Œç»´æŠ¤ï¼‰

å†æ¬¡æé†’ï¼Œè¿™ä¸€å°èŠ‚è®²çš„éƒ¨åˆ†éƒ½å¿½ç•¥äº†ä¹‹åè°ƒæ•´å­æ ‘å·¦åæ€§è´¨çš„è¿‡ç¨‹ï¼Œå®é™…ä¸Šè¿™ä¹Ÿå°±å•çº¯æ˜¯ä¸€ä¸ªç»´æŠ¤å †æ€§è´¨çš„è¿‡ç¨‹--åªéœ€è¦å¯¹**æœ€å³è·¯å¾„ Top-Down æˆ–è€… Bottom-Up è¿›è¡Œç»´æŠ¤å³å¯**

---

#### æ’å…¥
æ’å…¥å¯ä»¥ç›´æ¥çœ‹ä½œæ˜¯å’Œåªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹çš„æ ‘çš„åˆå¹¶

---

#### åˆ é™¤
åˆ é™¤æ“ä½œä¹Ÿæ¯”è¾ƒç®€å•ï¼Œåªéœ€è¦å¯¹è¢«åˆ é™¤èŠ‚ç‚¹çš„ä¸¤ä¸ªå­©å­åšåˆå¹¶æ“ä½œå³å¯

è¿™é‡Œè´´ä¸€æ®µä»£ç æ–¹ä¾¿ç†è§£
```C
LeftistHeapNode * del(LeftistHeapNode * cur, ElementType x) {
    if (cur->val == x) {
        // Just return the merge of the children.
        return merge(cur->l, cur->r);
    } else {
        // Not this subtree.
        if (cur->val > x) return cur;

        // Otherwise, search the `x`.
        if (cur->l != NULL) del(cur->l, x);
        if (cur->r != NULL) del(cur->r, x);

        // Adjust the dist bottom-up.
        adjust(cur);
    }
}
```

---

## Skew Heap
!!! quote "link" 
    Wikipedia: https://en.wikipedia.org/wiki/Skew_heap

---

### æ¦‚è¿°
Skew Heap å…¶å®æ˜¯ Leftist Heap çš„ä¸€ç§è‡ªé€‚åº”ç‰ˆæœ¬ï¼Œå®ƒä»¬äºŒè€…ä¹‹é—´çš„å…³ç³»å°±ç±»ä¼¼äº AVL Tree å’Œ Splay Tree çš„å…³ç³»ï¼ˆäº‹å®ä¸Šï¼Œå‘æ˜ Skew Heap çš„äººå’Œå‘æ˜ Splay Tree çš„äººæ˜¯åŒä¸€ä¸ªäººï¼‰

Skew Heap æ˜¯ä¸€ç§å…·æœ‰å †æ€§è´¨çš„äºŒå‰æ ‘ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰åƒ Leftist Heap ä¸€æ ·çš„å¯¹ç»“æ„ä¸Šçš„é™åˆ¶ï¼Œå¹¶æ²¡æœ‰è¯¸å¦‚ Npl è¿™æ ·çš„ä¿¡æ¯å­˜å‚¨åœ¨å„ä¸ªèŠ‚ç‚¹ä¸Šï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€ä¸€ä¸ª Skew Heap çš„ Right Path å¯èƒ½ä¼šéå¸¸é•¿ï¼Œè¿™å¯¼è‡´äº†æ‰€æœ‰æ“ä½œçš„æœ€åæ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$çº§åˆ«çš„ï¼Œä½†æ˜¯å°±åƒ Spaly Tree ä¸€æ ·ï¼Œæ‰€æœ‰æ“ä½œåœ¨æ‘Šè¿˜æ„ä¹‰ä¸‹çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(logn)$çº§åˆ«çš„

!!! tip "å¦ä¸€ç§è§†è§’"
    è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹å·¦åå †ï¼Œç”±äºéœ€è¦è‡ªä¸‹è€Œä¸Šåœ°ç»´æŠ¤ distï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•è¿›è¡Œå¹¶å‘æ“ä½œã€‚å›é¡¾ AVL æ ‘ï¼ŒåŒæ ·ä¸ºäº†ç»´æŠ¤å®ƒæ¯”è¾ƒä¸¥æ ¼çš„å¹³è¡¡æ€§è´¨ï¼Œæˆ‘ä»¬ä¹Ÿæ— æ³•è¿›è¡Œå¹¶å‘æ“ä½œï¼Œè€Œçº¢é»‘æ ‘åˆ™é€šè¿‡ä¸€ä¸ªèƒ½å¤Ÿä»…ä»…é€šè¿‡å˜è‰²å°±èƒ½è°ƒæ•´çš„é»‘é«˜æ¥è§„é¿äº†å¿…é¡»è‡ªä¸‹è€Œä¸Šç»´æŠ¤çš„é—®é¢˜ï¼Œå®ç°äº†å¹¶å‘ã€‚

    æ¢å¥è¯æ¥è¯´ï¼Œè¦æƒ³å°†å·¦åå †æ”¹å˜åœ°èƒ½å¤Ÿè¿›è¡Œè‡ªä¸Šè€Œä¸‹ç»´æŠ¤ï¼Œå°±éœ€è¦æ”¹å˜ç”šè‡³æ”¾å¼ƒå®ƒçš„å·¦åæ€§è´¨çš„ä¸¥æ ¼æ€§â€”â€”è€Œè¿™å°±æ˜¯æ–œå †çš„ç”±æ¥ã€‚

---

### åˆå¹¶
æ–œå †ä¹Ÿéœ€è¦æ»¡è¶³å¤§æ ¹å †ï¼ˆå°æ ¹å †ï¼‰çš„æ€§è´¨ï¼Œè€Œå®ƒçš„åˆå¹¶å’Œå·¦åå †çš„åˆå¹¶ä¹Ÿååˆ†ç±»ä¼¼ï¼Œåªä¸è¿‡æˆ‘ä»¬è¿™æ¬¡**æ— æ¡ä»¶çš„äº¤æ¢å·¦å³å­æ ‘**ï¼Œæ¢å¥è¯æ¥è¯´ï¼Œä¸ç®¡å·¦åæ€§è´¨å¦‚ä½•å˜åŒ–ï¼Œæˆ‘ä»¬éƒ½ä¼šé€‰æ‹©äº¤æ¢å‚ä¸åˆå¹¶çš„å·¦å³å­æ ‘ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸éœ€è¦åœ¨å›æº¯çš„æ—¶å€™æ‰è¿›è¡Œå·¦å³å­æ ‘çš„äº¤æ¢ï¼Œäºæ˜¯å°±å®ç°äº†å®Œå…¨çš„è‡ªä¸Šè€Œä¸‹ã€‚

è®©æˆ‘ä»¬æ¥çœ‹çœ‹ wiki é‡Œç»™å‡ºçš„ ğŸŒ°ï¼š

!!! eg "ğŸŒ° from wikipedia"
    === "Frame 0"
        ![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/SkewHeapMerge1.svg/540px-SkewHeapMerge1.svg.png)

        è¿™æ˜¯æˆ‘ä»¬éœ€è¦åˆå¹¶çš„ä¸¤ä¸ªå †ã€‚
    === "Frame 1"
        ![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/SkewHeapMerge7.svg/1280px-SkewHeapMerge7.svg.png){width=40%}

        çœç•¥äº†ä¸­é—´çš„æ­¥éª¤ï¼Œå¯ä»¥å°è¯•æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œæ¯ä¸€æ¬¡åˆå¹¶æ“ä½œç»“æŸä¹‹åéƒ½äº¤æ¢å·¦å³å­æ ‘ã€‚

å¤§æ¦‚çš„æ“ä½œç±»ä¼¼æ˜¯æ¯æ¬¡å…ˆæ¯”è¾ƒä¸¤ä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹å¤§å°ï¼ŒæŠŠå¤§çš„å­æ ‘å¾€å°çš„å­æ ‘åˆå¹¶ï¼Œå…·ä½“åˆå¹¶è¿‡ç¨‹æ˜¯ï¼Œå°†å°çš„å­æ ‘çš„å·¦å³å­æ ‘äº¤æ¢ï¼ŒæŠŠæ–°çš„å·¦å­æ ‘ç æ‰ï¼Œè®©è¢«ç æ‰çš„å·¦å­æ ‘å’Œå¾…åˆå¹¶çš„æ ‘åˆå¹¶åä½œä¸ºæ–°çš„å·¦å­æ ‘;

å¦‚æœé‡åˆ°ç©ºèŠ‚ç‚¹å’Œéç©ºæ ‘åˆå¹¶æ—¶ï¼Œè‹¥éç©ºèŠ‚ç‚¹æ˜¯è¯¥æ ‘å”¯ä¸€çš„æœ€å³è·¯å¾„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦äº¤æ¢å·¦å³å­æ ‘ï¼›å¦åˆ™äº¤æ¢å·¦å³å­æ ‘ã€‚

å½“ç„¶ï¼Œå®ƒä¹Ÿæ˜¯æ”¯æŒè¿­ä»£çš„å†™æ³•çš„ï¼Œå’Œæ˜¯å’Œä¹‹å‰çš„åšæ³•ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥æ’åºæ¯ä¸€â€œæ¡â€ï¼Œç„¶åå†åˆå¹¶ã€‚Wikipedia ä¸Šæä¾›äº†ä¸€ç³»åˆ—çš„è¿‡ç¨‹å›¾ï¼Œä½†æ˜¯é‚£ä¸ªè¿‡ç¨‹å›¾æœ‰ç‚¹è‡ªä¸‹è€Œä¸Šçš„æ„æ€ï¼Œä½†æ˜¯å®é™…ä¸Šè‡ªä¸Šè€Œä¸‹åšä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚å¦‚æœæœ‰å…´è¶£å¯ä»¥å»çœ‹çœ‹ Wiki ä¸Šçš„è¿‡ç¨‹ï¼š[ğŸ”—](https://en.wikipedia.org/wiki/Skew_heap#Non-recursive_merging)ã€‚

---

### æ‘Šè¿˜åˆ†æ

!!! quote "link"
    Halifuda:https://www.cnblogs.com/halifuda/p/14364632.html

è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨åŠ¿èƒ½æ³•åˆ†ææ‘Šè¿˜å¤æ‚åº¦

åˆ†æ skew heap çš„å‡æ‘Šå¤æ‚åº¦ï¼Œä¸»è¦å°±æ˜¯åˆ†æ**åˆå¹¶**æ“ä½œçš„å¤æ‚åº¦ï¼Œå› ä¸ºå…¶ä»–æ“ä½œéƒ½å¯ä»¥è½¬åŒ–ä¸ºåˆå¹¶æ“ä½œã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦å®šä¹‰åŠ¿èƒ½å‡½æ•°ï¼š

!!! definition "åŠ¿èƒ½å‡½æ•°"
    æˆ‘ä»¬å®šä¹‰ $\Phi(Heap) = \text{number of heavy node in } Heap$ã€‚

å…¶ä¸­ï¼Œé¢å¤–éœ€è¦å®šä¹‰ heavy node å’Œ light nodeï¼š

!!! definition "heavy node & light node"
    å¯¹äºä¸€ä¸ªå­å † $H$ï¼Œå¦‚æœ $size(H.\text{right.descendant}) \geq \frac{1}{2}size(H)$ï¼Œåˆ™ $H$ æ˜¯ heavy nodeï¼Œå¦åˆ™æ˜¯ light nodeã€‚ 

    ??? extra "\@ cy'ppt"
        A node p is heavy if the number of descendants of pâ€™s right subtree is at least half of the number of descendants of p, and light otherwise.  Note that the number of descendants of a node includes the node itself.

æ˜¾ç„¶ï¼Œå¯¹äº heavy node å’Œ light nodeï¼Œä»¥åŠåˆå¹¶æ“ä½œï¼Œæœ‰è¿™ä¹ˆä¸€äº›æ€§è´¨ï¼š

!!! property "properties"
    1. å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ˜¯ heavy nodeï¼Œå¹¶ä¸”åœ¨å…¶å³å­æ ‘å‘ç”Ÿäº†åˆå¹¶ï¼ˆåŒ…æ‹¬ç¿»è½¬ï¼‰ï¼Œé‚£ä¹ˆå®ƒ**ä¸€å®š**å˜ä¸ºä¸€ä¸ª light nodeï¼›
    2. å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ˜¯ light nodeï¼Œå¹¶ä¸”åœ¨å…¶å³å­æ ‘å‘ç”Ÿäº†åˆå¹¶ï¼ˆåŒ…æ‹¬ç¿»è½¬ï¼‰ï¼Œé‚£ä¹ˆå®ƒ**å¯èƒ½**å˜ä¸ºä¸€ä¸ª heavy nodeï¼›
    3. åˆå¹¶è¿‡ç¨‹ä¸­ï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹çš„ heavy/light å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆå®ƒ**åŸå…ˆ**ä¸€å®šåœ¨å †çš„æœ€å³ä¾§è·¯å¾„ä¸Šï¼›

åˆ—å‡ºå…¬å¼ï¼š

$$
\hat{c} = c + \Phi(H_{merged}) - \Phi(H_x) - \Phi(H_y)
$$

å…¶ä¸­ï¼Œ$c$ ä¸ºåˆå¹¶æ“ä½œçš„ï¼ˆæœ€åï¼‰å¤æ‚åº¦ï¼Œ$H_{merged}$ ä¸ºåˆå¹¶åçš„å †çš„åŠ¿èƒ½ï¼Œ$H_x$ å’Œ $H_y$ åˆ†åˆ«ä¸ºåˆå¹¶å‰çš„ä¸¤ä¸ªå †çš„åŠ¿èƒ½ã€‚

æ ¹æ® property 3ï¼Œåœ¨åˆå¹¶è¿‡ç¨‹ä¸­å¹¶éæ‰€æœ‰èŠ‚ç‚¹éƒ½æ”¶åˆ°å½±å“ã€‚æˆ‘ä»¬å¯ä»¥å•ç‹¬è®°å½• $l_{x}$ ä¸º $H_x$ æœ€å³ä¾§è·¯å¾„ä¸Šçš„ light node æ•°é‡ï¼Œ$h_{x}$ ä¸º $H_x$ æœ€å³ä¾§è·¯å¾„ä¸Šçš„ heavy node æ•°é‡ï¼Œ$h^0_{x}$ ä¸º $H_x$ æ‰€æœ‰ä¸åœ¨æœ€å³ä¾§è·¯å¾„ä¸Šçš„ heavy node æ•°é‡ï¼ˆå³ $\text{count of heavy nodes of } H_x = H_x + H^0_x$ï¼‰ã€‚

äºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸Šå¼å†™å¼€ï¼š

$$
\left\{
    \begin{aligned}
        c &= l_x + h_x + l_y + h_y &(1)\\
        \Phi(H_{merged}) &\leq l_x + h^0_x + l_y + h^0_y &(2)\\
        \Phi(H_x) &= h_x + h^0_{x} &(3)\\
        \Phi(H_y) &= h_y + h^0_{y} &(4)
    \end{aligned}
\right.
$$

å…¶ä¸­ç¨å¾®åšä¸€äº›è§£é‡Šï¼š

1. $(1)$ï¼š$c$ ä¸ºåˆå¹¶æ“ä½œçš„ï¼ˆæœ€åï¼‰å¤æ‚åº¦ï¼Œå³æˆ‘ä»¬çš„æšä¸¾æ¶‰åŠäº†ä¸¤ä¸ªå †æ‰€æœ‰çš„å³ä¾§è·¯å¾„ï¼›
2. $(2)$ï¼šåœ¨åˆå¹¶æ“ä½œä»¥åï¼Œæ ¹æ® property 1 å’Œ property 2ï¼Œå¯ä»¥å¾—åˆ°è¿™ä¸ªä¸ç­‰å¼ï¼›
3. $(3)$ å’Œ $(4)$ï¼šæ ¹æ®åŠ¿èƒ½å‡½æ•°çš„å®šä¹‰å¾—åˆ°ï¼›

äºæ˜¯ï¼Œå°†å®ƒä»¬ä»£å…¥å¾—åˆ°ç»“æœï¼š

$$
\begin{aligned}
\hat{c} 
    &= c + \Phi(H_{merged}) - \Phi(H_x) - \Phi(H_y) \\
    &\leq (l_x + h_x + l_y + h_y)
    + (l_x + h^0_x + l_y + h^0_y)
    - (h_x + h^0_{x})
    - (h_y + h^0_{y}) \\
    &\leq 2(l_x + l_y) \\
\hat{c}
    &= O(\log{N})
\end{aligned}
$$

??? proof "å³è·¯å¾„ light node çš„æ•°é‡"
    è¯æ˜ $l=O(logâ¡N)$

    >æ³¨ï¼š$l$ æ˜¯å †ï¼ˆæœ€ï¼‰å³ä¾§è·¯å¾„çš„è½»èŠ‚ç‚¹æ•°

    æˆ‘ä»¬å¯ä»¥å…ˆè¯æ˜ï¼šå¯¹äºå³ä¾§è·¯å¾„ä¸Šå¸¦æœ‰ $l$ ä¸ªè½»ç»“ç‚¹çš„æ–œå †ï¼Œè‡³å°‘æœ‰ $2lâˆ’1$ ä¸ªç»“ç‚¹ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœä¸€ä¸ªå †æœ‰ $N$ ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå®ƒå³ä¾§è·¯å¾„ä¸Šçš„è½»èŠ‚ç‚¹ä¸ªæ•°ä¸º $O(logâ¡N)$ï¼Œå³ $l=O(logâ¡N)$ï¼Œæ‰€ä»¥åªè¦è¯å‡ºå‰è€…ï¼Œåè€…è‡ªç„¶æˆç«‹ã€‚æˆ‘ä»¬é‡‡ç”¨å½’çº³æ³•è¯æ˜ï¼ˆè¯æ˜è¿‡ç¨‹ç±»ä¼¼å·¦åå †é‚£ä¸ªå®šç†çš„è¯æ˜ï¼‰ï¼š

    å½“ $l=1$æ—¶ï¼Œæ˜¾ç„¶æˆç«‹
    å‡è®¾ $lâ‰¤n$ æ—¶ï¼Œè¯¥ç»“è®ºæˆç«‹
        é‚£ä¹ˆå½“ $l=n+1$ æ—¶ï¼Œæˆ‘ä»¬å…ˆæ‰¾åˆ°å³ä¾§è·¯å¾„çš„ç¬¬äºŒä¸ªè½»èŠ‚ç‚¹ï¼Œæ ¹æ®å½’çº³å‡è®¾çŸ¥ï¼Œä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘è‡³å°‘æœ‰ $2^lâˆ’1$ ä¸ªèŠ‚ç‚¹
        å†æ‰¾ç¬¬ä¸€ä¸ªè½»èŠ‚ç‚¹ï¼Œç”±è½»èŠ‚ç‚¹çš„å®šä¹‰çŸ¥ï¼Œå®ƒçš„å·¦å­æ ‘èŠ‚ç‚¹æ•°ä¸€å®šå¤§äºå³å­æ ‘èŠ‚ç‚¹æ•°ï¼Œè€Œä¸Šé¢æåˆ°çš„å­æ ‘ä½äºå®ƒçš„å³å­æ ‘å¤„ï¼Œæ‰€ä»¥ä»¥ç¬¬ä¸€ä¸ªè½»èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘è‡³å°‘æœ‰ $2Ã—(2^lâˆ’1)+1 = 2^{l+1} - 1$ ä¸ªèŠ‚ç‚¹ã€‚é‚£ä¹ˆæ•´ä¸ªå †çš„èŠ‚ç‚¹ä¸ªæ•°ä¸€å®šå¤§äº $2Ã—(2^lâˆ’1)+1 = 2^{l+1} - 1$ ï¼Œå¾—è¯

!!! info "ä¸€äº›å°ç»“è®º"
    === "Conclusion 1"

        å‘ä¸€ä¸ªç©ºçš„æ–œå †ä¾æ¬¡æ’å…¥ $1\text{~}2^{kâˆ’1}(k>4)$è¿™å‡ ä¸ªå…ƒç´ åï¼Œå¾—åˆ°çš„å †æ˜¯ä¸€æ£µæ»¡äºŒå‰æ ‘
        
    === "Conclustion 2"
        The right path of a skew heap can be arbitrarily long

        skew heap æœ€å³è·¯å¾„ä¸Šåªæœ‰è½»ç»“ç‚¹å—ç±»ä¼¼ leftist heap çš„é™åˆ¶ã€‚

        ç›¸å¯¹è€Œè¨€ï¼Œleftist heap çš„æœ€å³è·¯å¾„å°±ä¸èƒ½è¿™ä¹ˆä»»æ„äº†ï¼Œå®ƒå— logâ¡N é™åˆ¶

!!! note "Self-adjusting Data Structure"
    In typical applications of data structures, it is not a single operation that is performed, but rather a sequence of operations, and the relevant complexity measure is not the time taken by one operation but the total time of a sequence. Hence instead of imposing any explicit structural constraint, we allow the data structure to be in an arbitrary state, and we design the access and update algorithms to adjust the structure in a simple, uniform way, so that the efficiency of future operations is improved. We call such a data structure **self-adjusting**. For example skew heaps and splay trees are such kind of structures.